No,Question,Option A,Option B,Option C,Option D,Option E,Correct Answer,Explanation,Competency
1,Which architectural component ensures that the actual state of cluster resources converges towards the desired state defined in their specifications?,kube-apiserver,kube-scheduler,Controllers (within kube-controller-manager),kubelet,etcd,C,"Controllers implement reconciliation loops. They watch the desired state via the API server and interact with resources to make the current state match the desired state (e.g., ReplicaSet controller ensuring the right number of Pods exist).",Kubernetes Architecture
2,A Pod specification includes two containers: one web server and one log shipper. How do these containers communicate efficiently over the network within the Pod?,Via a Kubernetes Service,Via the node's primary IP address,Via localhost and shared network namespace,Via an automatically created NetworkPolicy,Via distinct Pod IP addresses assigned to each container,C,"Containers within the same Pod share the same network namespace, meaning they can communicate using localhost and standard inter-process communication mechanisms as if they were on the same machine.",Containers
3,What is the primary role of kubelet on a worker node?,To schedule Pods onto the node,To store the state of Pods running on the node,To ensure containers described in PodSpecs assigned to its node are running,To manage network routing rules for Services,To authenticate API requests originating from the node,C,"The kubelet is the primary node agent. It receives PodSpecs from the API server and interacts with the container runtime (e.g., containerd) to start, stop, and manage the containers defined in those Pods, reporting their status back to the control plane.",Kubernetes Architecture
4,Which Kubernetes resource provides a mechanism for grouping API objects and providing a scope for names?,Label,Annotation,Namespace,Deployment,ServiceAccount,C,"Namespaces create logical partitions within a cluster, allowing teams or applications to operate independently. Resource names must be unique within a Namespace, but not necessarily across the entire cluster.",Kubernetes Resources
5,"When interacting with the Kubernetes API server using kubectl, what is the typical format used for defining resource manifests?",JSON,XML,YAML,Protocol Buffers,Plain Text,C,"While the API server can accept JSON, YAML is the overwhelmingly conventional and human-readable format used in configuration files (manifests) passed to kubectl for creating or updating resources.",Kubernetes API
6,What core Kubernetes concept allows Deployments to perform rolling updates with zero downtime?,Managing StatefulSets,Utilizing PersistentVolumes,Incrementally replacing Pods managed by ReplicaSets,Direct communication with the kube-scheduler,Modifying NetworkPolicy rules dynamically,C,"Deployments manage ReplicaSets. During a rolling update, a Deployment creates a new ReplicaSet with the updated Pod template and gradually scales it up while scaling down the old ReplicaSet, ensuring service availability throughout the process.",Kubernetes Resources
7,Which component is responsible for making the ultimate decision about which node a newly created Pod should run on?,kubelet,kube-apiserver,kube-scheduler,kube-controller-manager,The Pod's ServiceAccount,C,"The kube-scheduler watches for Pods without an assigned node and selects the most suitable node based on filtering (resource requests, affinity rules, etc.) and scoring algorithms.",Scheduling
8,How does Kubernetes typically handle the failure of a container within a Pod?,By deleting the entire Pod immediately,By restarting the failed container based on the Pod's restartPolicy,By scheduling a new Pod on a different node,By marking the Node as unschedulable,By alerting the kube-scheduler to find a replacement container,B,"The kubelet monitors container health. If a container fails, the kubelet restarts it according to the Pod's restartPolicy (Always, OnFailure, Never). The Pod itself continues to exist on the same node.",Containers
9,What distinguishes a Kubernetes Secret from a ConfigMap?,"Secrets are namespaced, ConfigMaps are not","ConfigMaps store configuration data, Secrets store sensitive data (base64 encoded)","Secrets can only be mounted as environment variables, ConfigMaps as files","ConfigMaps are automatically encrypted at rest, Secrets are not","Secrets are immutable once created, ConfigMaps are mutable",B,"Both are used for configuration, but Secrets are intended for sensitive information (passwords, keys) and are stored base64 encoded (not truly encrypted by default in etcd, though). ConfigMaps are for non-sensitive configuration data. Both are namespaced and can be mounted in multiple ways.",Kubernetes Resources
10,Which of the following is NOT a standard component of the Kubernetes control plane?,etcd,kube-apiserver,kube-scheduler,containerd,kube-controller-manager,D,"containerd is a container runtime; it typically runs on worker nodes (managed by the kubelet) to handle container execution, not as part of the central control plane.",Kubernetes Architecture
11,What is the purpose of labels in Kubernetes?,To provide detailed descriptive information about a resource,To define network access rules between resources,To attach identifying metadata for selection and organization,To specify resource requests and limits for containers,To store multi-line configuration data,C,"Labels are key/value pairs attached to objects (like Pods, Services) used to organize resources and allow users/controllers to select subsets of objects (e.g., a Service selecting Pods with app=backend).",Kubernetes Resources
12,"When defining a Pod, what does the spec.containers[].image field specify?",The base operating system for the container,The specific container image (and tag) to run,The command to execute inside the container,The resource limits for the container,The network port the container will listen on,B,"This field tells the container runtime which image (e.g., nginx:1.21 or myrepo/myapp:v2.5) to pull from a registry and use to create the container process.",Containers
13,"If a Pod needs access to specific hardware features available only on certain nodes, which scheduling mechanism is most suitable?",ResourceQuota,NetworkPolicy,PodDisruptionBudget,Taints and Tolerations or Node Affinity,HorizontalPodAutoscaler,D,"Taints applied to nodes repel Pods that don't Tolerate them. Node Affinity allows Pods to express preferences or requirements for nodes based on node labels (which can represent hardware features, location, etc.). Both help ensure Pods land on appropriate nodes.",Scheduling
14,"Which API object represents a single point of access to a set of Pods providing the same functionality, acting as an internal load balancer?",Ingress,EndpointSlice,Service,ReplicaSet,NetworkPolicy,C,A Service defines a logical set of Pods (usually selected by labels) and provides a stable IP address and DNS name. kube-proxy ensures traffic to the Service IP is load-balanced across the healthy backend Pods.,Kubernetes Resources
15,What is the relationship between a Deployment and a ReplicaSet?,A ReplicaSet manages multiple Deployments,A Deployment watches ReplicaSets for scaling signals,A Deployment declaratively manages ReplicaSets to orchestrate Pod updates,"ReplicaSets are used only for stateful applications, Deployments for stateless",They are independent controllers managing Pod lifecycles,C,"A Deployment provides declarative updates for Pods and ReplicaSets. It creates and manages ReplicaSets, handling rolling updates or rollbacks by manipulating the desired replica count of underlying ReplicaSets. You typically interact with Deployments, not ReplicaSets directly.",Kubernetes Resources
16,The Kubernetes API server performs several actions when receiving a request. Which action verifies if the authenticated user is allowed to perform the requested operation?,Authentication,Admission Control,Authorization,Rate Limiting,Validation,C,"After Authentication (who are you?), Authorization (e.g., via RBAC) checks if the identified user has the necessary permissions (Role/ClusterRole bindings) to perform the action (e.g., create, get, delete) on the specific resource (e.g., pods) in the target namespace.",Kubernetes API
17,What is the primary function of etcd within the Kubernetes architecture?,To run the container runtime interface,To schedule Pods across available nodes,"To provide reliable, distributed storage for cluster state and configuration",To manage network policies and ingress rules,To execute health checks against running containers,C,"etcd is the consistent key-value store that acts as the source of truth for the entire cluster. All configuration, state, and metadata are persisted here, ensuring consistency across the control plane.",Kubernetes Architecture
18,Which field in a Pod's specification is crucial for the kube-scheduler to determine if a node has sufficient resources?,spec.nodeName,spec.containers[].ports,spec.containers[].resources.requests,spec.serviceAccountName,spec.restartPolicy,C,The resources.requests field (for CPU and memory) indicates the minimum amount of resources the container needs. The scheduler uses this to filter out nodes that cannot meet these requests.,Scheduling
19,What fundamental concept allows Kubernetes controllers to operate effectively without needing constant instructions?,Imperative command execution,The reconciliation loop (Control Loop),Direct manipulation of etcd,Event-driven webhooks,Stateful session management,B,"Controllers continuously watch the desired state (from the API server) and the current state (observed in the cluster), taking actions (via the API server) to make the current state match the desired state. This is the core principle of Kubernetes automation.",Kubernetes Architecture
20,Which OCI (Open Container Initiative) specification defines how container runtimes should execute containers?,Image Specification,Distribution Specification,Runtime Specification (CRI is Kubernetes' interface to this),Network Specification (CNI is related),Storage Specification,C,The OCI Runtime Specification outlines how to run a container filesystem bundle. Kubernetes uses the Container Runtime Interface (CRI) as an abstraction layer over runtimes like containerd or CRI-O that implement this standard.,Containers
21,You need to provide non-sensitive configuration data (like a URL endpoint or logging level) to a Pod. Which resource is most appropriate?,Secret,ConfigMap,Annotation,ResourceQuota,DownwardAPI,B,"ConfigMaps are designed specifically for decoupling non-sensitive configuration artifacts from container images, allowing configurations to be managed independently.",Kubernetes Resources
22,"If you want a specific Pod to run on every node in the cluster (or a subset matching certain criteria), which workload resource should you use?",Deployment,StatefulSet,DaemonSet,Job,ReplicaSet,C,"A DaemonSet ensures that a copy of a Pod runs on all (or some specified) nodes. This is useful for node-level agents like log collectors, monitoring agents, or CNI plugins.",Kubernetes Resources
23,"What does it mean for the Kubernetes API to be ""declarative""?",API calls must be made sequentially,"Users specify the desired end state, not the steps to reach it",The API only accepts YAML formatted requests,API responses always include the full resource specification,"The API can only create resources, not update or delete them",B,"Users declare the desired state of resources (e.g., ""I want 3 replicas of this Pod""). Kubernetes controllers then figure out the sequence of actions needed to achieve and maintain that state. Contrast this with imperative approaches (""run container X"", ""scale up by 1"").",Kubernetes API
24,Which mechanism prevents the kube-scheduler from placing Pods on a Node that is undergoing maintenance or is otherwise unsuitable?,ResourceQuotas,NetworkPolicies,Taints on the Node and Tolerations on the Pod,PodDisruptionBudgets,PriorityClasses,C,"A Taint applied to a Node repels Pods. Pods can express Tolerations for specific taints, allowing them to be scheduled onto those nodes. This is commonly used to cordon nodes for maintenance or dedicate nodes for specific workloads.",Scheduling
25,"What part of the Kubernetes system is responsible for managing the lifecycle of EndpointSlice objects, which track Pod IPs for Services?",kube-proxy,kubelet,endpointslice-controller (within kube-controller-manager),kube-scheduler,coredns / kube-dns,C,"The endpointslice-controller (part of kube-controller-manager) watches Services and their selector-matched Pods, creating and managing EndpointSlices to store the Pod IP addresses and port information efficiently. kube-proxy consumes this information.",Kubernetes Architecture
26,Which component translates a Service's virtual IP address into actual Pod IP addresses on each node?,etcd,kube-apiserver,coredns / kube-dns,kube-proxy,kubelet,D,"kube-proxy, running on each node, watches Services and Endpoints/EndpointSlices. It programs network rules (e.g., iptables, IPVS) to intercept traffic destined for a Service's ClusterIP and directs it to one of the healthy backend Pod IPs.",Kubernetes Architecture
27,A StatefulSet is often preferred over a Deployment for running databases. Why?,StatefulSets have simpler configuration,Deployments cannot use Persistent Storage,"StatefulSets provide stable, unique network IDs and persistent storage per Pod",Deployments automatically handle database schema migrations,StatefulSets require less CPU and memory resources,C,"StatefulSets provide guarantees crucial for stateful apps: stable network identifiers (e.g., db-0, db-1), stable persistent storage linked to each identity, and ordered, graceful deployment and scaling.",Kubernetes Resources
28,What is the primary goal of the Open Container Initiative (OCI)?,To create a commercial container platform,To define open standards around container formats and runtime,To manage the Kubernetes source code repository,To develop container networking plugins (CNI),To provide free container image hosting,B,"OCI aims to establish common, open, minimal standards for container image formats and container runtime execution to ensure interoperability and prevent fragmentation in the container ecosystem.",Containers
29,Which kubectl command is used to view the logs of a running container within a Pod?,kubectl get pod <pod-name> --logs,kubectl describe pod <pod-name>,kubectl logs <pod-name> [-c <container-name>],kubectl attach <pod-name> -c <container-name>,kubectl exec <pod-name> -- tail /var/log/messages,C,kubectl logs fetches the logs (stdout/stderr) from a specified container within a Pod. The -c flag is needed if the Pod has multiple containers.,Kubernetes API
30,What is the function of an Admission Controller in the Kubernetes API request lifecycle?,To authenticate the user making the request,To authorize the requested operation,To mutate or validate API objects before they are persisted in etcd,To schedule the Pod onto a suitable node,To route network traffic to the correct Pod,C,"Admission Controllers intercept API requests after authentication and authorization but before persistence. They can mutate objects (e.g., inject sidecars, set default values) or validate them (e.g., enforce security policies, check resource quotas).",Kubernetes API
31,"Which resource defines constraints on the total amount of compute resources (CPU, memory) that can be consumed within a specific Namespace?",LimitRange,ResourceQuota,NetworkPolicy,PodSecurityPolicy / PodSecurityAdmission,PriorityClass,B,"A ResourceQuota limits the aggregate resource consumption (CPU, memory, storage, object counts) within a Namespace, preventing overuse and ensuring fair sharing among users or teams.",Kubernetes Resources
32,Consider a Pod that needs to perform a one-time initialization task before its main application container starts. Which container type is best suited for this?,Sidecar Container,Ephemeral Container,Init Container,Main Application Container,Job Container,C,"Init Containers run sequentially before the main application containers in a Pod start. They must complete successfully for the main containers to launch, making them ideal for setup tasks like database schema migration, fetching configuration, or waiting for dependencies.",Containers
33,What is the purpose of the metadata.ownerReferences field in a Kubernetes object?,To specify the user who created the object,"To link the object to its managing controller (e.g., ReplicaSet to Deployment)",To list labels used for selecting the object,To store annotations related to the object's owner,To define the Namespace the object belongs to,B,"ownerReferences create parent-child relationships between objects. This enables cascading deletion (deleting the owner deletes dependents) and helps controllers identify the objects they manage. For example, a ReplicaSet Pod will have an ownerReference pointing to the ReplicaSet.",Kubernetes Resources
34,Which statement best describes the relationship between Kubernetes and Docker (as of 2025)?,Kubernetes requires Docker to be installed on all nodes.,Docker is the only container runtime supported by Kubernetes.,"Kubernetes primarily interacts with container runtimes via CRI (e.g., containerd, CRI-O), abstracting Docker.",Docker manages the Kubernetes control plane components.,Kubernetes is a component within the Docker Enterprise platform.,C,"Kubernetes deprecated the direct Docker integration (dockershim). It now interacts with OCI-compliant runtimes like containerd (which Docker itself uses) or CRI-O via the Container Runtime Interface (CRI). While Docker might be installed, K8s doesn't use it directly in the same way.",Containers
35,"If multiple Pods need to share persistent data, which volume type allows simultaneous mounting by multiple Pods (potentially with read/write access)?",hostPath,emptyDir,A PersistentVolume with an accessMode like ReadWriteMany (RWX),secret volume,configMap volume,C,"PersistentVolumes (PVs) represent external storage. Their accessModes define how they can be mounted. ReadWriteOnce (RWO) allows mounting by a single node, while ReadWriteMany (RWX) allows simultaneous read/write mounting by multiple nodes (requires a capable storage backend like NFS).",Kubernetes Resources
36,"Which control plane component is primarily responsible for running controllers like the Node Controller, Deployment Controller, and Service Controller?",etcd,kube-apiserver,kube-scheduler,kube-controller-manager,cloud-controller-manager,D,"The kube-controller-manager bundles core Kubernetes controllers into a single binary. It runs controllers that handle node lifecycle, workload management (Deployments, ReplicaSets), service endpoints, namespace creation, etc.",Kubernetes Architecture
37,What is the purpose of a LimitRange object within a Namespace?,To limit the total resource usage of the entire Namespace,To set default resource requests/limits for containers and validate min/max bounds,To restrict network traffic between Pods in the Namespace,To control which users can create resources in the Namespace,To define storage quotas for PersistentVolumeClaims,B,A LimitRange operates at the container/Pod level within a Namespace. It can enforce minimum/maximum resource constraints and specify default request/limit values if they aren't explicitly set in the Pod spec. ResourceQuota limits the Namespace total.,Kubernetes Resources
38,Which kubectl command would you use to apply a configuration defined in my-app.yaml declaratively?,kubectl create -f my-app.yaml,kubectl replace -f my-app.yaml,kubectl apply -f my-app.yaml,kubectl patch -f my-app.yaml,kubectl run -f my-app.yaml,C,"kubectl apply is the standard command for declarative resource management. It creates resources if they don't exist or calculates and applies necessary changes if they do, based on the definition in the file.",Kubernetes API
39,How does the kube-scheduler handle Pods with defined affinity rules?,It ignores affinity rules if resource requests cannot be met.,It uses affinity rules as the primary factor for node selection.,It considers affinity/anti-affinity rules during the filtering and scoring phases.,It delegates affinity processing to the kubelet.,"It only processes podAffinity, not nodeAffinity.",C,Affinity rules (node and inter-pod) influence scheduling decisions. Required affinity rules act as filters (nodes must match). Preferred affinity rules contribute to the scoring phase (nodes matching preferred rules get higher scores).,Scheduling
40,"What is the concept of ""desired state reconciliation"" fundamental to Kubernetes?",Users manually reconcile cluster state using kubectl.,Controllers continuously observe and work to match actual state to declared state.,etcd automatically corrects discrepancies between desired and actual state.,kubelet reconciles container state based solely on node health.,The API server rejects any configuration that deviates from the current state.,B,"This is the core operational principle. Users declare the desired state (via API objects), and various controllers run loops comparing this desired state with the actual observed state, taking corrective actions (creating/deleting/updating resources) to close the gap.",Kubernetes Architecture
41,Which resource attribute is primarily used by a Service to determine which Pods should receive traffic?,metadata.name,metadata.namespace,metadata.labels (matched by the Service's selector),spec.nodeName,status.podIP,C,"A Service definition includes a selector field, which specifies a set of labels. The Service continuously identifies Pods matching these labels and directs traffic to them (via Endpoints/EndpointSlices managed by controllers).",Kubernetes Resources
42,"What type of container volume shares the Pod's lifecycle and is initially empty, useful for temporary data sharing between containers in a Pod?",hostPath,persistentVolumeClaim,emptyDir,nfs,secret,C,An emptyDir volume is created when a Pod is assigned to a node and exists as long as that Pod is running on that node. Its 1  contents are lost when the Pod is deleted. It's ideal for scratch space or sharing files between containers within the same Pod.,Kubernetes Resources
43,Which Kubernetes API endpoint would kubectl get pods likely interact with?,/api/v1/nodes,/api/v1/namespaces/{namespace}/pods,/apis/apps/v1/deployments,/healthz,/metrics,B,"Core Kubernetes resources like Pods, Services, and Namespaces typically reside under the /api/v1 endpoint. The request would be scoped to a specific namespace (or query all namespaces) and target the pods resource type.",Kubernetes API
44,What is a potential consequence of setting container resource limits much higher than requests?,Improved Pod scheduling priority,Reduced cost for node resources,"Potential for node resource exhaustion and Pod eviction (""noisy neighbor"" effect)",Faster container startup times,Automatic vertical scaling of the container,C,"Requests are used for scheduling, guaranteeing the resource. Limits enforce an upper bound. If limits are high, a container might consume resources needed by other Pods on the node, potentially leading to CPU throttling or OOM (Out Of Memory) kills and eviction if node pressure occurs.",Scheduling
45,Which architectural pattern describes running a helper container alongside a main application container in the same Pod to provide auxiliary functionality?,Init Container,Ephemeral Container,Sidecar Container,Ambassador Container,Adapter Container,C,"The Sidecar pattern involves adding containers to a Pod to extend or enhance the main application container (e.g., for logging, monitoring, proxying) without modifying the main application's code. They share the same lifecycle and network/storage namespaces.",Containers
46,How are API resources like Deployments and StatefulSets grouped in the Kubernetes API?,Under the core v1 API group (/api/v1),They are not part of any API group.,Under specific API groups like apps/v1,Under the scheduling.k8s.io API group,Under the batch/v1 API group,C,"Kubernetes organizes its API into groups to facilitate evolution. Workload resources like Deployments, StatefulSets, ReplicaSets, and DaemonSets are part of the apps API group, currently at version v1.",Kubernetes API
47,"If a Node fails, what component detects this failure and updates the Node's status in etcd?",kubelet on the failed node,kube-proxy on peer nodes,node-controller (within kube-controller-manager),kube-scheduler,etcd itself through distributed consensus,C,"The node-controller, running within the kube-controller-manager, is responsible for monitoring Node health (based on heartbeats from kubelet) and updating the Node status (e.g., setting conditions like Ready to False or Unknown).",Kubernetes Architecture
48,Which resource configuration allows a Pod to securely access the Kubernetes API server using the Pod's own identity?,Mounting a Secret containing API keys,Configuring a ServiceAccount for the Pod and mounting its token,Using hostNetwork: true,Defining an Ingress resource,Setting environment variables with kubeconfig data,B,"A ServiceAccount provides an identity for a Pod. Kubernetes automatically creates and mounts a token for this ServiceAccount into the Pod (unless disabled), which applications can use to authenticate to the API server. Permissions are granted via RBAC.",Kubernetes Resources
49,What is the primary purpose of using annotations on Kubernetes resources?,To select resources for operations (like Services selecting Pods),To define resource constraints and quotas,To attach arbitrary non-identifying metadata (often used by tools),To specify the desired number of replicas for a workload,To enforce security policies on Pods,C,"While labels are for identifying and selecting objects, annotations are meant for attaching non-identifying metadata, often used by tools, libraries, or operators to store configuration, pointers, or state information relevant to their function.",Kubernetes Resources
50,"In a typical Kubernetes cluster setup, where does the kube-scheduler run?",On every worker node,As a Pod managed by a DaemonSet,As a static Pod or systemd service on a control plane node,Inside the etcd cluster,As part of the kubelet binary,C,"The kube-scheduler is a critical control plane component. It usually runs directly on a control plane node, often managed as a static Pod (defined by a manifest file read by the kubelet on the control plane node) or as a system service.",Kubernetes Architecture