No,Question,Option A,Option B,Option C,Option D,Option E,Correct Answer,Explanation,Competency
1,What core principle of cloud-native application delivery emphasizes treating infrastructure components and application deployments as disposable units replaced on update?,Statefulness,Mutability,Immutability,Manual Configuration,High Cohesion,C,"Immutability means that once an artifact (like a container image or a VM image) is created, it is not changed. Updates happen by deploying new instances based on new artifacts and replacing the old ones. This leads to more predictable and reliable deployments compared to mutating running instances.",Application Delivery Fundamentals
2,"In GitOps, what serves as the single source of truth for the desired state of the application and infrastructure?",The running cluster state queried via kubectl.,A configuration management database (CMDB).,A Git repository containing declarative configuration manifests.,A wiki page maintained by the operations team.,The CI/CD pipeline logs.,C,"The core idea of GitOps is that the Git repository contains the authoritative definition of the desired state (e.g., Kubernetes manifests, Helm charts, Kustomize overlays). All changes to the desired state are made via commits to this repository.",GitOps
3,What is the primary goal of Continuous Integration (CI) in a CI/CD pipeline?,To automatically deploy every code change directly to production.,To frequently merge code changes into a central repository and automatically build and test the application.,To manage the Git repository permissions for developers.,To provision the underlying infrastructure required for deployment.,To manually review code quality before merging.,B,CI focuses on automating the process of integrating code changes from multiple contributors into a shared repository. Each integration is verified by an automated build and test 1  sequence to detect issues early. It does not typically involve deployment to production itself (that's CD).,CI/CD
4,How does the declarative nature of Kubernetes manifests support cloud-native application delivery principles?,By requiring developers to specify exact imperative commands for deployment.,"By allowing users to define the desired state, leaving the how to the orchestrator's control loop.",By enforcing the use of specific programming languages for applications.,By automatically generating Git repositories for each application.,By integrating directly with billing systems for cost management.,B,"Declarative configuration (like K8s YAML) focuses on specifying the desired end state (e.g., ""I want 3 replicas of this image running with this config""). The orchestrator (Kubernetes) continuously works to reconcile the actual state with this desired state. This contrasts with imperative approaches that specify step-by-step commands.",Application Delivery Fundamentals
5,What is the role of a GitOps agent or operator (like Argo CD or Flux) running within the Kubernetes cluster?,To build container images from source code committed to Git.,To run automated tests against application code in Git.,To continuously monitor the Git repository and reconcile the cluster state to match the desired state in Git.,To provide a web UI for developers to manually apply manifests to the cluster.,To manage user access control to the Git repository.,C,"The GitOps operator runs in the cluster and acts as the reconciliation engine. It detects differences between the desired state defined in Git and the actual state in the cluster, then takes action (e.g., using kubectl apply) to converge the cluster state towards the desired state.",GitOps
6,What distinguishes Continuous Delivery from Continuous Deployment within a CI/CD pipeline?,Continuous Delivery involves manual testing; Continuous Deployment is fully automated.,Continuous Delivery deploys to production automatically; Continuous Deployment requires manual approval.,Continuous Delivery ensures code is always deployable; Continuous Deployment automatically deploys it.,Continuous Delivery focuses on infrastructure; Continuous Deployment focuses on application code.,Continuous Delivery uses Git; Continuous Deployment uses SVN.,C,"Continuous Delivery automates the pipeline up to the point where the build artifact is ready and verified for release, but a manual approval step is typically required for production deployment. Continuous Deployment goes further, automatically deploying every verified build to production without manual intervention.",CI/CD
7,Why is a feedback loop important in cloud-native application delivery?,It eliminates the need for version control systems like Git.,It ensures that only senior developers can deploy applications.,"It provides visibility into the deployment process and application health, enabling quick response to issues.",It mandates the use of specific cloud providers for hosting.,It replaces the need for automated testing.,C,"Effective application delivery requires feedback loops at various stages – CI tests provide feedback on code quality, deployment tools report success/failure, and observability tools provide feedback on application health post-deployment. This allows teams to detect and respond to problems quickly.",Application Delivery Fundamentals
8,"In the ""pull-based"" GitOps model, where does the initiative for updating the cluster state originate?",The CI server pushes changes directly to the Kubernetes API server.,The developer manually runs kubectl apply from their workstation.,The GitOps operator running inside the cluster pulls changes from the Git repository.,An external webhook triggers the update based on Git commits.,The Git repository pushes changes directly to the cluster nodes.,C,"In the pull model, the GitOps operator deployed within the cluster periodically checks the Git repository for changes or receives webhook notifications. It then ""pulls"" the manifests and applies them to the same cluster where it's running. This is generally considered more secure than external systems pushing changes in.",GitOps
9,"What is the primary function of a container registry (e.g., Docker Hub, Google Container Registry, Harbor) in the CI/CD process?",To store source code repositories.,To run automated unit and integration tests.,To store and distribute container images built by the CI process.,To host Kubernetes manifest files declaratively defining deployments.,To manage DNS records for deployed applications.,C,"After the CI pipeline successfully builds and potentially tests a container image, it pushes this immutable artifact to a container registry. The CD system (or GitOps operator) then pulls the specified image version from the registry during deployment to the target environment (e.g., Kubernetes).",CI/CD
10,What cloud-native delivery concept involves gradually shifting traffic from an old version of an application to a new version while monitoring performance?,Blue/Green Deployment,Rolling Update,Canary Release,A/B Testing,Recreate Deployment,C,"A Canary Release introduces the new version to a small subset of users/traffic first. If monitoring shows the new version is stable and performs well, traffic is gradually shifted until the new version handles all traffic. This minimizes the blast radius of potential issues.",Application Delivery Fundamentals
11,What benefit does GitOps provide regarding auditability and rollback?,It eliminates the need for logging application events.,It relies on manual documentation stored outside Git for tracking changes.,"Every change to the desired state is a Git commit, providing a full audit trail and easy rollback via git revert.",Rollbacks must be performed by directly modifying the live cluster state.,Audit trails are only available through proprietary third-party tools.,C,"Since Git is the source of truth, the Git history (commits, authors, timestamps) serves as a detailed audit log of all changes to the desired state. Rolling back to a previous known good state is as simple as reverting the corresponding commit(s) in Git and letting the operator reconcile.",GitOps
12,"In a typical Kubernetes CI/CD pipeline, what stage usually occurs immediately after building the container image?",Deploying the image to the production Kubernetes cluster.,Pushing the container image to a container registry.,Running end-to-end tests requiring a fully deployed environment.,Manually approving the release for deployment.,Configuring DNS records for the new application version.,B,"Once the image is built (docker build), the next logical step is to store this immutable artifact in a central, accessible location – the container registry. Subsequent steps like testing or deployment will pull the image from this registry.",CI/CD
13,"Which deployment strategy involves running two identical production environments, only one of which receives live traffic at any time?",Canary Release,Rolling Update,Blue/Green Deployment,Shadow Deployment,Recreate Deployment,C,"In Blue/Green deployment, two environments (""Blue"" - current, ""Green"" - new) exist. The new version is deployed and tested in the Green environment. Once ready, traffic is switched (e.g., via load balancer or DNS) from Blue to Green. Blue can be kept as a standby for quick rollback or decommissioned.",Application Delivery Fundamentals
14,"How does the concept of ""configuration drift"" relate to GitOps?",GitOps intentionally introduces configuration drift for flexibility.,Configuration drift is the desired outcome of a GitOps workflow.,GitOps aims to prevent or automatically correct configuration drift by continuously reconciling the cluster state with Git.,Configuration drift refers to changes made only within the Git repository.,GitOps requires manual intervention to detect configuration drift.,C,"Configuration drift occurs when the actual state of the cluster differs from the desired state defined in configuration (e.g., due to manual kubectl commands). GitOps operators constantly detect this drift and automatically apply changes to bring the cluster back in sync with the Git repository, thus preventing drift.",GitOps
15,"What role does automated testing (unit, integration, end-to-end) play in achieving reliable Continuous Delivery/Deployment?",It slows down the delivery pipeline unnecessarily.,It provides the confidence needed to automate deployments by verifying application correctness at different levels.,It is only necessary for applications written in specific languages.,It replaces the need for monitoring and observability post-deployment.,It primarily focuses on testing the underlying Kubernetes infrastructure.,B,"Automated tests are crucial gates in the CI/CD pipeline. They verify that code changes haven't introduced regressions and that the application functions as expected. Passing these tests provides confidence that the artifact is safe to deploy, enabling automation.",CI/CD
16,Which practice aligns best with the principle of using declarative specifications for application delivery?,Writing shell scripts that execute a series of kubectl commands to deploy.,Using Kubernetes manifests (YAML) stored in Git to define the desired application state.,Manually configuring applications through a graphical user interface after deployment.,Storing application configuration directly within container images.,Using SSH to log into nodes and manually start application processes.,B,"Kubernetes YAML manifests are declarative – they describe the desired end state. This aligns perfectly with cloud-native principles and tools like GitOps, where these manifests define the target for reconciliation loops. Imperative scripts or manual steps are less reliable and harder to automate consistently.",Application Delivery Fundamentals
17,What is a potential challenge or consideration when implementing GitOps?,It makes rollbacks significantly more difficult than traditional methods.,It requires developers to have direct kubectl apply access to production clusters.,"Managing secrets securely within a Git-based workflow requires careful handling (e.g., using sealed secrets, external secret managers).",It eliminates the need for any CI pipeline processes like building and testing.,It only works with specific proprietary Git hosting providers.,C,"Storing plain-text secrets in Git is a major security risk. GitOps workflows require solutions to manage secrets safely, such as encrypting them in Git (e.g., Sealed Secrets, SOPS) and decrypting them only within the cluster, or fetching them from external secret management systems (e.g., HashiCorp Vault, AWS Secrets Manager).",GitOps
18,"What is ""pipeline-as-code"" in the context of CI/CD?",Writing application code directly within the CI/CD tool's UI.,"Defining the CI/CD pipeline's stages, steps, and configuration using code stored in version control (e.g., Jenkinsfile, GitLab CI YAML).",Generating pipeline definitions automatically based on monitoring data.,A specific programming language used exclusively for writing CI/CD pipelines.,Storing pipeline execution logs as application code.,B,"Pipeline-as-code treats the definition of the build, test, and deployment pipeline itself as code. This definition lives in version control alongside the application code, enabling versioning, review, and easier management of the pipeline's structure and logic.",CI/CD
19,"How does the concept of ""least privilege"" apply to GitOps operators?",The operator should run with cluster-admin privileges for maximum flexibility.,"The operator's permissions (e.g., via ServiceAccount and RBAC) should be scoped only to the resources it needs to manage.",Developers interacting with Git should have least privilege; the operator needs full access.,The operator should only have read-only access to the Git repository.,"Least privilege only applies to CI/CD tools, not GitOps operators.",B,"For security, the GitOps operator running in the cluster should be granted only the minimum RBAC permissions required to manage the specific resources defined in its target Git repositories and namespaces. Granting cluster-admin privileges unnecessarily increases the potential blast radius if compromised.",GitOps
20,What is the purpose of tools like Helm or Kustomize in Kubernetes application delivery?,To replace the need for container image registries.,To provide runtime monitoring and alerting for applications.,"To manage, template, and customize Kubernetes manifest files, simplifying complex deployments.",To automatically write application source code based on high-level requirements.,To enforce network security policies between Pods.,C,"Deploying applications often involves many related Kubernetes manifests. Helm (packaging/templating) and Kustomize (overlay-based customization) help manage this complexity, allowing for parameterization, reuse, and environment-specific configuration without duplicating large amounts of YAML.",CI/CD
21,"In a GitOps workflow, how are changes typically promoted across different environments (e.g., staging to production)?",By directly modifying the live production cluster using kubectl.,By manually copying manifests from a staging directory to a production directory on a local machine.,By merging or promoting changes between branches or directories in the Git repository that represent different environments.,"By re-running the entire CI pipeline with a ""production"" flag.",By configuring the GitOps operator to ignore environment differences.,C,"A common GitOps pattern is to represent each environment (dev, staging, prod) as a separate branch or directory in Git. Promoting a change involves merging code/configuration from the staging branch/directory to the production branch/directory. The GitOps operator watching production then applies the change.",GitOps
22,"What is the significance of using unique, immutable tags (e.g., Git SHA, semantic version) for container images in a CI/CD pipeline?",It allows developers to overwrite existing tags like latest for simplicity.,It makes it difficult to track which version of the code is running in production.,"It ensures that deployments are predictable and repeatable, always pulling the exact intended version of the image.",It reduces the storage space required in the container registry.,It is primarily for aesthetic purposes in dashboard displays.,C,"Using mutable tags like latest is dangerous, as the underlying image can change without the deployment configuration changing, leading to unexpected behavior. Immutable tags ensure that my-app:v1.2.3 always refers to the exact same image build, making deployments deterministic and rollbacks reliable.",CI/CD
23,What is a key benefit of automating application delivery pipelines?,It increases the need for manual intervention and approvals at each stage.,It introduces more opportunities for human error during deployment.,"It leads to faster, more reliable, and consistent deployments, enabling quicker feedback loops.",It makes the deployment process less transparent and harder to audit.,It primarily benefits only very small development teams.,C,"Automation removes manual steps, reducing the chance of human error and speeding up the entire process from code commit to deployment. This consistency and speed enable teams to release value more frequently and get feedback faster.",Application Delivery Fundamentals
24,"If a discrepancy exists between the state defined in Git and the live cluster state, what is the expected behavior of a GitOps reconciliation loop?",It sends an alert to the developer asking them to manually fix the cluster.,It automatically updates the Git repository to match the cluster state.,It detects the drift and takes action to modify the cluster state to match the desired state in Git.,It halts all further deployments until the discrepancy is manually resolved.,It ignores the discrepancy unless explicitly told to sync.,C,"The core function of the GitOps operator's reconciliation loop is to ensure the cluster state mirrors the state defined in Git. If drift is detected, the operator will apply the necessary changes (create, update, delete resources) to the cluster to bring it back into alignment with the Git repository.",GitOps
25,What security practice should be integrated into a CI pipeline dealing with container images?,Disabling all network access for the CI runner.,Storing plain-text API keys directly in the pipeline script.,"Scanning container images for known vulnerabilities (CVEs) using tools like Trivy, Clair, or Snyk.",Granting the CI runner root privileges on the build host.,Bypassing all automated tests to speed up the build process.,C,Integrating automated vulnerability scanning into the CI pipeline helps identify and potentially block images with known security flaws before they are pushed to a registry or deployed. This is a crucial step in securing the software supply chain.,CI/CD
26,Which component is typically NOT considered part of a core GitOps workflow?,A Git repository containing declarative manifests.,An automated mechanism to apply changes from Git to the cluster (Operator).,A mechanism to observe the cluster state and compare it with Git (Operator).,An imperative script run manually by developers to deploy applications.,A feedback mechanism reporting synchronization status.,D,"GitOps relies on declarative configurations and automated reconciliation. Manually executed imperative scripts bypass the core GitOps loop and principles, potentially leading to configuration drift and loss of auditability.",GitOps
27,"In CI/CD for Kubernetes, why is it often better to update the image tag in a deployment manifest rather than using the latest tag?",Using latest triggers automatic rollbacks on failure.,The latest tag provides better caching performance in the container registry.,Updating a specific tag declaratively triggers a controlled rollout; latest doesn't reliably signal updates.,The latest tag is not supported by most container registries.,Using specific tags requires less storage space in Git.,C,"Kubernetes Deployments typically trigger a rollout only when the Pod template changes. Simply pushing a new image with the latest tag doesn't change the manifest, so Kubernetes might not update running Pods. Using a unique tag (e.g., v1.2.3) forces a change in the manifest, reliably triggering the desired rollout strategy.",CI/CD
28,"What does ""Shift Left"" mean in the context of security in application delivery?",Moving security testing and considerations to the rightmost (production) stage of the pipeline.,"Integrating security checks and practices earlier in the development lifecycle (e.g., in CI).",Assigning all security responsibilities solely to a dedicated security team.,Ignoring security concerns until after an application has been deployed.,Focusing security efforts only on the underlying infrastructure.,B,"""Shift Left"" encourages incorporating security practices (like code analysis, dependency scanning, image vulnerability scanning) earlier in the software development lifecycle (closer to the ""left"" side, where code is written) rather than treating security as an afterthought just before release.",Application Delivery Fundamentals
29,"Can GitOps manage resources outside of Kubernetes (e.g., cloud databases, DNS records)?","No, GitOps is strictly limited to managing Kubernetes API objects.","Yes, potentially, if using tools like Crossplane or Terraform controllers that extend the GitOps model to manage external resources.",Only if the external resources are manually synchronized with Git state.,"No, managing external resources always requires a separate imperative process.","Yes, by storing credentials for cloud providers directly in Git manifests.",B,"While core GitOps tools focus on Kubernetes, the principles can be extended. Tools like Crossplane allow defining external cloud resources using Kubernetes custom resources (CRDs). A GitOps operator can then manage these CRDs, effectively extending the GitOps workflow to provision and manage external resources declaratively.",GitOps
30,"What is the purpose of a ""smoke test"" in a CD pipeline, often run immediately after deployment?",To perform comprehensive end-to-end functional testing of all features.,To check the basic health and availability of the newly deployed application or service.,To run security vulnerability scans on the deployed application.,To gather detailed performance metrics under simulated heavy load.,To verify the configuration stored in the Git repository.,B,"A smoke test is a quick, basic check to ensure the application starts correctly and key functionalities are available (e.g., can it serve a simple request? Is the homepage accessible?). It's not exhaustive but provides rapid feedback on whether the deployment was fundamentally successful.",CI/CD
31,How does GitOps handle failed deployments or rollbacks compared to traditional methods?,Rollbacks require complex manual intervention on the cluster.,Failures are ignored until the next successful Git commit.,Rollbacks are typically achieved by reverting the change in Git and letting the operator synchronize the cluster to the previous known good state.,Failed deployments automatically trigger a full cluster rebuild.,Rollbacks are not possible within a GitOps framework.,C,"Because the desired state is versioned in Git, rolling back is often as simple as git revert <commit-hash>. The GitOps operator detects this change in the desired state (now pointing to the older configuration) and automatically rolls the cluster back accordingly.",GitOps
32,What is the relationship between Continuous Integration (CI) and GitOps?,GitOps replaces the need for a CI server entirely.,"CI builds artifacts (e.g., container images); GitOps often consumes these artifacts for deployment based on Git state.",CI is responsible for deploying manifests; GitOps is responsible for building images.,They are mutually exclusive approaches to application delivery.,GitOps is a specific tool used only within CI pipelines.,B,"CI and GitOps are complementary. The CI pipeline typically handles building the application, running tests, and producing artifacts like container images (often pushing them to a registry). A commit updating a manifest in Git (e.g., with the new image tag) then triggers the GitOps workflow to deploy that artifact.",CI/CD & GitOps
33,Which cloud-native principle supports the idea of automating infrastructure provisioning alongside application deployment?,Infrastructure as Code (IaC),Manual server configuration,Stateful application design,High latency tolerance,Reactive programming,A,"IaC involves managing and provisioning infrastructure (networks, servers, load balancers, Kubernetes clusters) through machine-readable definition files (code), rather than manual configuration. This allows infrastructure changes to be versioned, tested, and automated alongside application code delivery.",Application Delivery Fundamentals
34,"In a pull-based GitOps model, how does the operator typically authenticate to the Git repository?",Using the developer's personal Git credentials stored in a Secret.,"Using SSH keys, deploy tokens, or access tokens configured specifically for the operator.",No authentication is required if the repository is public.,Using Kubernetes ServiceAccount tokens intended for API server access.,"Authentication is handled by the CI server, not the operator.",B,"The GitOps operator needs credentials to access the Git repository. Secure methods include generating an SSH key pair and adding the public key to the repository's deploy keys, or using specific access tokens with limited scope, configured securely within the operator's deployment.",GitOps
35,"What does a ""release candidate"" (RC) typically signify in a software release process?","The final, generally available (GA) version of the software.",An unstable nightly build intended only for internal testing.,"A version believed to be stable and potentially the final release, undergoing final testing.",A prototype version demonstrating initial concepts.,A security patch applied to a previous release.,C,"A release candidate is a build that has passed significant testing (e.g., QA, beta) and is considered potentially ready for final release. It's distributed for final verification before being declared the official stable version.",CI/CD
36,What is a key benefit of decoupling application configuration from container images?,It simplifies the container build process by including configuration directly.,It allows the same container image to be deployed across different environments with varying configurations.,It eliminates the need for version control for configuration.,It makes container images larger and slower to pull.,It prevents the use of Kubernetes ConfigMaps and Secrets.,B,"Baking configuration into images requires rebuilding the image for every configuration change (e.g., database URL). Externalizing configuration (via ConfigMaps, Secrets, environment variables populated by the delivery system) allows the same immutable image artifact to be promoted across environments (dev, staging, prod) by applying different configurations.",Application Delivery Fundamentals
37,How does GitOps facilitate collaboration between development and operations teams?,By requiring operations teams to manually approve every developer commit.,By providing separate Git repositories for developers and operators with no overlap.,By using a shared Git repository and pull requests as a common mechanism for proposing and reviewing infrastructure and application changes.,By eliminating the need for an operations team entirely.,By forcing developers to manage the underlying Kubernetes infrastructure.,C,"GitOps provides a common workflow centered around Git. Developers can propose application deployment changes, and operations can propose infrastructure changes via pull requests (PRs) in the same repository (or related ones). This makes changes transparent and allows for cross-functional review and collaboration.",GitOps
38,What is the role of Helm in a GitOps workflow?,Helm replaces the Git repository as the source of truth.,Helm is the GitOps operator that reconciles the cluster state.,"Helm charts (stored in Git) can declaratively define the application, and GitOps tools deploy/manage Helm releases based on Git state.",Helm is used only for building container images within the CI pipeline.,Helm directly monitors application performance and triggers rollbacks.,C,"Helm charts provide a way to package and template Kubernetes applications. In a GitOps context, the desired state in Git might be defined using Helm charts and value files. The GitOps operator then uses Helm commands (e.g., helm template, helm install/upgrade) under the hood to render manifests and manage the application release.",GitOps & CI/CD
39,"What does the ""convergence"" mean in the context of a GitOps reconciliation loop?",The process of merging multiple Git branches into one.,The act of manually applying configuration changes to the cluster.,The process where the GitOps operator brings the actual cluster state into alignment with the desired state defined in Git.,The final stage of a CI pipeline where tests are run.,The point where application performance meets SLO targets.,C,"The GitOps operator continuously compares the desired state (Git) and actual state (cluster). If they differ, it takes actions to make the actual state match the desired state. This process of driving the cluster towards the state defined in Git is called convergence.",GitOps
40,Which Kubernetes feature allows performing updates with zero downtime by incrementally replacing old Pods with new ones?,StatefulSet update strategies.,Job completions.,Deployment rolling update strategy.,DaemonSet node affinity rules.,ResourceQuota limits.,C,"The default strategy for Kubernetes Deployments is RollingUpdate. It ensures that updates happen gradually – stopping old Pods and starting new ones incrementally – while ensuring a minimum number of Pods remain available throughout the process, thus enabling zero-downtime updates.",CI/CD
41,"What is the ""Application Definition"" in a GitOps context?",The source code of the application written by developers.,The container image stored in a registry.,"The declarative configuration (e.g., K8s YAML, Helm Charts, Kustomize overlays) stored in Git defining the application deployment.",The documentation explaining how to use the application.,The results of the automated tests run in the CI pipeline.,C,"The Application Definition encompasses all the declarative files stored in Git that specify how the application should be configured and run in the target environment. This includes Deployments, Services, ConfigMaps, Secrets (managed securely), etc.",GitOps
42,How do feature flags complement CI/CD and progressive delivery strategies like canary releases?,Feature flags replace the need for CI/CD pipelines entirely.,Feature flags allow enabling/disabling application features at runtime without requiring a full redeployment.,Feature flags are used only for configuring infrastructure components.,Feature flags eliminate the need for version control systems.,Feature flags require manual code changes for every activation.,B,"Feature flags allow decoupling deployment from release. Code for new features can be deployed (via CI/CD) to production but remain hidden behind a flag. The feature can then be enabled for specific users (canary, A/B test) or gradually rolled out via a configuration change at runtime, without a new deployment.",CI/CD
43,What is a key difference between kubectl apply and kubectl create? Why is apply often preferred in automated delivery pipelines?,create updates existing resources; apply only creates new ones.,apply stores configuration locally; create stores it in the cluster.,apply performs a declarative update (merging changes); create fails if the resource already exists.,create is faster for large numbers of resources.,apply requires cluster-admin privileges; create does not.,C,"kubectl apply calculates the difference between the local manifest and the live resource configuration and applies only the necessary changes. It can both create and update resources idempotently. kubectl create fails if the resource already exists, making apply much better suited for repeatable, automated CI/CD or GitOps workflows.",Application Delivery Fundamentals
44,"If using GitOps with multiple clusters (e.g., dev, staging, prod), how might configurations be managed efficiently?","By maintaining completely separate, unrelated Git repositories for each cluster.","By using the exact same manifests for all clusters, ignoring differences.",Using tooling like Kustomize or Helm to manage base configurations and environment-specific overlays/values within a single or related Git repositories.,By manually applying changes to each cluster sequentially.,By running a different GitOps operator in each cluster with identical config.,C,"Tools like Kustomize (using overlays) or Helm (using value files) allow defining a common base configuration and layering environment-specific settings (e.g., replica counts, resource limits, domain names) on top. This promotes DRY (Don't Repeat Yourself) principles while managing configurations across environments in Git.",GitOps
45,What is a common trigger for a Continuous Integration pipeline?,A schedule running once per week.,A manual button click by the project manager.,"A code commit pushed to the version control repository (e.g., Git).",A new vulnerability discovered in a base image.,A successful deployment to the production environment.,C,"The most common trigger for a CI pipeline is a push event to the Git repository (e.g., pushing commits to a feature branch or merging a pull request). This ensures that every code change automatically initiates the build and test process.",CI/CD
46,Which factor is LEAST relevant when choosing between a pull-based and push-based GitOps approach?,Security considerations regarding cluster API access.,The specific programming language used by the application being deployed.,Network policies restricting traffic flow between the CI system and the cluster.,Scalability requirements for managing many clusters.,The location of the Git repository relative to the cluster.,B,"GitOps focuses on deploying and managing applications based on manifests, regardless of the language the application itself is written in. Security, network topology, and scalability are key factors influencing the choice between pull (agent in cluster) and push (CI pushes to cluster) models.",GitOps
47,"In a CI/CD context, what is static application security testing (SAST)?",Analyzing running application behavior for security flaws.,Scanning container images for known vulnerabilities in dependencies.,Analyzing application source code or compiled binaries for security vulnerabilities without executing the code.,Performing penetration testing against a deployed application.,Checking firewall rules protecting the application.,C,"SAST tools analyze the application's source code, bytecode, or binary code while it's ""static"" (not running) to identify potential security vulnerabilities like SQL injection flaws, buffer overflows, or insecure coding patterns. It's often integrated early in the CI pipeline.",CI/CD
48,What is the role of idempotency in automated application delivery?,Ensuring that operations always produce different results each time they are run.,Ensuring that performing the same operation multiple times produces the same result as performing it once.,Making sure that configuration files are stored only in memory.,Requiring manual intervention for every deployment step.,Idempotency relates only to database transaction management.,B,"Idempotency is crucial for reliable automation. If a deployment script or GitOps reconciliation can be run multiple times without unintended side effects (i.e., applying the same state multiple times results in the same final state), it makes the automation safer and more resilient to transient failures or reruns. kubectl apply is designed to be idempotent.",Application Delivery Fundamentals
49,"How can secrets (e.g., API keys, passwords) be securely injected into Pods managed via GitOps without storing plain text in Git?",By embedding secrets directly within the container image layers.,"Using tools like Sealed Secrets (encrypts secrets in Git, decrypted by a controller in-cluster) or referencing external secret managers (e.g., Vault).",Storing secrets as plain text ConfigMaps in Git.,Passing secrets as command-line arguments to the GitOps operator.,Disabling secrets management entirely for simplicity.,B,"Secure secret management in GitOps requires mechanisms to avoid plain text in Git. Common solutions involve in-cluster decryption of encrypted secrets stored in Git (Sealed Secrets, Mozilla SOPS) or using operators/injectors that fetch secrets directly from systems like HashiCorp Vault, AWS Secrets Manager, etc., at deploy time.",GitOps
50,What is a key outcome of adopting mature CI/CD practices?,Longer lead times for changes due to increased process overhead.,Reduced deployment frequency to minimize risk.,"Faster, more reliable delivery of value to end-users through automation and rapid feedback.",Increased reliance on manual testing and deployment procedures.,Complete elimination of bugs in production environments.,C,"Mature CI/CD pipelines automate the build, test, and deployment process, significantly reducing lead time (time from commit to production) and enabling more frequent, reliable releases. This allows businesses to deliver features and fixes to users faster and get feedback more quickly.",CI/CD